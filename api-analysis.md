# API split separation

## API identifiers mapping

We are porting the following API endpoints to NPQ. The transition should be as transparent as possible from the Lead Providers perspective:

## API endpoints

### V1

```
GET /api/v1/npq-applications
GET /api/v1/npq-applications/{id}
POST /api/v1/npq-applications/{id}/accept
POST /api/v1/npq-applications/{id}/reject
POST /api/v1/npq-applications/{id}/reject
GET /api/v1/participants/npq
GET /api/v1/participants/npq/{id}
PUT /api/v1/participants/npq/{id}/change-schedule
PUT /api/v1/participants/npq/{id}/defer
PUT /api/v1/participants/npq/{id}/defer
PUT /api/v1/participants/npq/{id}/resume
PUT /api/v1/participants/npq/{id}/withdraw
GET /api/v1/participants/npq/outcomes
GET /api/v1/participants/npq/{participant_id}/outcomes
POST /api/v1/participants/npq/{participant_id}/outcomes
GET /api/v1/participant-declarations
```

### V2

```
GET  /api/v2/npq-applications
GET  /api/v2/npq-applications.csv
GET  /api/v2/npq-applications/{application_id}
POST /api/v2/npq-applications/{application_id}/accept
POST /api/v2/npq-applications/{application_id}/reject
GET  /api/v2/npq-enrolments.csv
GET  /api/v2/participants/npq
GET  /api/v2/participants/npq/{participant_id}
PUT  /api/v2/participants/npq/{participant_id}/change-schedule
PUT  /api/v2/participants/npq/{participant_id}/defer
PUT  /api/v2/participants/npq/{participant_id}/resume
PUT  /api/v2/participants/npq/{participant_id}/withdraw
GET  /api/v2/participants/npq/outcomes
GET  /api/v2/participants/npq/{participant_id}/outcomes
POST /api/v2/participants/npq/{participant_id}/outcomes
GET /api/v3/participant-declarations
```

### V3

```
GET  /api/v3/npq-applications
GET  /api/v3/npq-applications/{application_id}
POST /api/v3/npq-applications/{application_id}/accept
POST /api/v3/npq-applications/{application_id}/reject
GET  /api/v3/participants/npq/outcomes
GET  /api/v3/participants/npq/{participant_id}/outcomes
POST /api/v3/participants/npq/{participant_id}/outcomes
GET  /api/v3/participants/npq
GET  /api/v3/participants/npq/{participant_id}
PUT  /api/v3/participants/npq/{participant_id}/change-schedule
PUT  /api/v3/participants/npq/{participant_id}/defer
PUT  /api/v3/participants/npq/{participant_id}/resume
PUT  /api/v3/participants/npq/{participant_id}/withdraw
GET /api/v3/participant-declarations
```

### Identifiers: technical analysis

The following analysis applies to the endpoints of the different API versions: v1, v2 and v3.

#### API endpoints that receive an `application_id`

```
# samples
GET  /api/v3/npq-applications/{application_id}
POST /api/v3/npq-applications/{application_id}/accept
POST /api/v3/npq-applications/{application_id}/reject
```

The parameter `application_id`:

1. Is generated by ECF.
2. Is [stored in the ￼`ecf_idf`￼](https://github.com/DFE-Digital/npq-registration/blob/452b3831254eb32c3e72c6118ee2980a1df72b6f/db/schema.rb#L32) in NPQ
3. Is returned to Lead Providers via [API endpoint response](%5Bresponse%20of%20this%20endpoint%5D%28https%3A//manage-training-for-early-career-teachers.education.gov.uk/api-reference/reference-v3.html#api-v3-npq-applications-id-accept-post-parameters%29).

##### Actions

1. No need to migrate ECF `application_id` as this information is already present in the attribute: `ecf_id` in the `applications` table in NPQ.
2. `application_id` will be returned to LP via the [response of this endpoint](https://manage-training-for-early-career-teachers.education.gov.uk/api-reference/reference-v3.html#api-v3-npq-applications-id-accept-post-parameters):
   1. For existing applications (previous to the split), [it will return ￼`ecf_id`￼ from the current ￼`applications`￼ table](https://github.com/DFE-Digital/npq-registration/blob/98cdef7b2e879588499a2cd4d3e72a087782c415/db/schema.rb#L33).
   2. For new applications (after split), it will return a new `UUID` which will be also stored in the same `applications` table (`ecf_id`) field.
3. Rename `ecf_id` to `application_lead_provider_id`, so we break the link between NPQ and ECF (ECF is no longer the owner of the identifiers).

**Conclusions:**

1. For existing `application_id` the endpoint in NPQ will continue managing / using the same `UUID` as ECF
2. For new applications, NPQ will generate the a new `UUID` which will have the same format that previous `UUID` generated from ECF.
3. The migrations of application identifiers will be transparent for Lead Providers

##### #### API endpoints that receive an `participant_id`s

> There is only one accepted application per course and participant

```
# Samples
GET  /api/v3/participants/npq/{participant_id}/outcomes
POST /api/v3/participants/npq/{participant_id}/outcomes
PUT  /api/v3/participants/npq/{participant_id}/change-schedule
PUT  /api/v3/participants/npq/{participant_id}/defer
PUT  /api/v3/participants/npq/{participant_id}/resume
PUT  /api/v3/participants/npq/{participant_id}/withdraw

```

The parameter `participant_id`:

1. Is currently generated and managed in `ECF`
2. `ECF` stores multiple participant identities per user, and has proven to be difficult to reason about. In NPQ we have decided to simplify them as NPQ requirements are simpler.
3. To all effects, in NPQ,  the `participant_id` is the `user_id`.

#### Actions

1. No need to migrate `participant_id` as this information is already present in the attribute: `ecf_id` in the `users` table in NPQ (this attribute stores the user `ID` in `ECF`)
2. The `participant_id` will be returned to LP via the endpoints
   - For existing participants, we will return the `ecf_id` from the current `users` table.
   - For new participants, we will return a new `UUID` which will be also stored in the `users` table (`ecf_id`) field.
3. Rename `ecf_id` to `lead_provider_participant_id`, so we break the link between NPQ and ECF.
4. Create a `Finder` in NPQ to locate an application using the course and the participant.

#### Open Questions

1. If `participant_id` is the same as the `user_id` in NPQ, we would need to do a mapping in `ECF` (this make it difficult for LP to use NPQ API directly for old applications).
2. In order to have an API in NPQ that is ready for LP to use directly for old applications, we would need to explore using `TRN`s)?

